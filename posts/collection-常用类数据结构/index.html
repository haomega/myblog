<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>collection 常用类的数据结构 - 小豪小豪</title><meta name=description content="Collection体系常用类 Set接口常用类  HashSet LinkedHashSet TreeSet  List接口常用类  ArrayList LinkedList Stack Vector（提供了一些线程安全的方法）  Map接口常用类  HashMap HashTable LinkedHashMap TreeMap  Set常用类数据结构 HashSet 内部维护了一个HashMapprivate transient HashMap<E,Object> map;，所有方法都是靠HashMap来完成。
LinkedHashMap 继承了HashSet，唯一与之不同的是内部维护的是LinkedHashMap而不是HashMap：
/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.)... **/ HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap<>(initialCapacity, loadFactor); } TreeSet内部也是维护了一个NavigableMap（TreeMap）。 详情请看Map。
List常用类数据结构 ArrayList内部维护了一个Object数组transient Object[] elementData;
LinkedList是链表结构，内部构造了含有前后指针的Node;
Stack extend Vector，所以内部也是一个Object数组，通过数组实现栈（先进后出），每次出栈最后一个数组元素。"><meta name=author content="小豪"><link href=https://haomega.github.io/myblog/css/stylesheet.min.c5f3513f5b80c2549e72d959bdae43941f36c204c7504248d1e05f5fa480f14a.css integrity="sha256-xfNRP1uAwlSectlZva5DlB82wgTHUEJI0eBfX6SA8Uo=" rel="preload stylesheet" as=style><link rel=apple-touch-icon href=https://haomega.github.io/myblog/apple-touch-icon.png><link rel=icon href=https://haomega.github.io/myblog/favicon.ico><meta name=generator content="Hugo 0.74.3"></head><body class=single id=top><header class=header><nav class=nav><p class=logo><a href=https://haomega.github.io/myblog/>小豪小豪</a></p><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://haomega.github.io/myblog/archives/>Archives</a></li><li><a href=https://haomega.github.io/myblog/tags/>Tags</a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>collection 常用类的数据结构</h1><div class=post-meta>小豪 · June 17, 2020</div></header><div class=post-content><h2 id=collection体系常用类>Collection体系常用类</h2><h3 id=set接口常用类>Set接口常用类</h3><ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul><h3 id=list接口常用类>List接口常用类</h3><ul><li>ArrayList</li><li>LinkedList</li><li>Stack</li><li>Vector（提供了一些线程安全的方法）</li></ul><h3 id=map接口常用类>Map接口常用类</h3><ul><li>HashMap</li><li>HashTable</li><li>LinkedHashMap</li><li>TreeMap</li></ul><h2 id=set常用类数据结构>Set常用类数据结构</h2><p>HashSet 内部维护了一个HashMap<code>private transient HashMap&lt;E,Object> map;</code>，所有方法都是靠HashMap来完成。</p><p>LinkedHashMap 继承了HashSet，唯一与之不同的是内部维护的是LinkedHashMap而不是HashMap：</p><pre><code>/**
     * Constructs a new, empty linked hash set.  (This package private
     * constructor is only used by LinkedHashSet.)...
**/
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
    }
</code></pre><p>TreeSet内部也是维护了一个NavigableMap（TreeMap）。
详情请看Map。</p><h2 id=list常用类数据结构>List常用类数据结构</h2><p>ArrayList内部维护了一个Object数组<code>transient Object[] elementData</code>;</p><p>LinkedList是链表结构，内部构造了含有前后指针的Node;</p><p>Stack extend Vector，所以内部也是一个Object数组，通过数组实现栈（先进后出），每次出栈最后一个数组元素。</p><h2 id=map常用类数据结构>Map常用类数据结构</h2><p>HashMap/HashTable</p><blockquote><p>HashMap 大致相当于HashTable，除了HashMap不是线程安全的，并且允许null作为Key或Value;</p></blockquote><p>HashMap的数据结构是Hash桶（数组加链表）<code>transient Node&lt;K,V>[] table</code>;</p><p>put逻辑：计算key的hash，根据hash通过取模（%）<code>(n - 1) & hash</code>计算桶位置，判空，非空的话遍历链表，如果key相等会替换原来的值，没有相同的就加到链表后。</p><p>LinkedHashMap extend HashMap，与之不通的是，它维护了一个双向链表（重新实现了桶，使之包含前后两个指向）</p><pre><code>/**
     * HashMap.Node subclass for normal LinkedHashMap entries.
     */
    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
        Entry&lt;K,V&gt; before, after;
        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
            super(hash, key, value, next);
        }
    }
</code></pre><p>TreeMap是红黑树的实现，具体可看<a href=https://juejin.im/post/5be529a5f265da615704fd45>这里</a>
‭</p><h2 id=总结>总结:</h2><p>Set的实现基本靠内部维护的HashMap类；</p><p>List有数组和链表实现，数组可以根据下标快速获取元素，删除慢；链表删除快，随机读写会比较慢，因为每次获取元素都要从第一个元素开始找。</p><p>HashMap的实现比较复杂，数据结构是数组加链表，虽然有链表实现，但是数据结构也是相同的，只不过桶的数据结构变成了具有双向链表的结构，也由于根据计算hash来确定元素存放位置，使得查找非常快。</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://haomega.github.io/myblog/>小豪小豪</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/adityatelange/hugo-PaperMod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top"><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://haomega.github.io/myblog/js/highlight.min.min.be617795b40f52d6ca2248c7fbf433c49211c7acfe8f221ac54f6b0007c66ea1.js integrity="sha256-vmF3lbQPUtbKIkjH+/QzxJIRx6z+jyIaxU9rAAfGbqE="></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
hljs.initHighlightingOnLoad();document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();document.querySelector(this.getAttribute("href")).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script></body></html>