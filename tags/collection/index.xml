<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>collection on 小豪小豪</title><link>https://haomega.github.io/myblog/tags/collection/</link><description>Recent content in collection on 小豪小豪</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Sat, 11 Jul 2020 16:00:33 +0800</lastBuildDate><atom:link href="https://haomega.github.io/myblog/tags/collection/index.xml" rel="self" type="application/rss+xml"/><item><title>HashMap 容量为什么是2的幂</title><link>https://haomega.github.io/myblog/posts/collection-hashmap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82/</link><pubDate>Sat, 11 Jul 2020 16:00:33 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-hashmap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82/</guid><description>HashMap桶的容量 HashMap是散列表的实现，使用桶+链表的数据结构；
将元素散列在各个桶中，HashMap默认的负载因子是0.75f，这是一个对于空间和时间取舍上的一个值，当元素和桶的数量超过负载因子时，桶会进行扩容，但是桶的容量一直保持为2的幂：
在初始化HashMap时，桶的容量为2的幂； 当HashMap桶的容量不够进行扩容时，桶的容量也是2的幂; Why？ 当我们put一个值到HashMap时，会有如下步骤：
计算key的hashcode； 依据key的hashcode决定存储位置，会对hashcode取余； 将key-value放入桶。 在进行第2步时，HashMap不是使用%进行取余，而是index = (n - 1) &amp;amp; hash
可以这样理解：
当n为2的幂时，比如n=8，二进制表示为1000，所以（n-1）的二进制为0111，进行&amp;amp;操作时，能快速的丢弃除后三位的所有1 这样就不用取余计算了，我们知道取余计算是乘法运算，与位运算相比，位运算更加快速。</description></item><item><title>collection 常用类的数据结构</title><link>https://haomega.github.io/myblog/posts/collection-%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 17 Jun 2020 14:54:52 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>Collection体系常用类 Set接口常用类 HashSet LinkedHashSet TreeSet List接口常用类 ArrayList LinkedList Stack Vector（提供了一些线程安全的方法） Map接口常用类 HashMap HashTable LinkedHashMap TreeMap Set常用类数据结构 HashSet 内部维护了一个HashMapprivate transient HashMap&amp;lt;E,Object&amp;gt; map;，所有方法都是靠HashMap来完成。
LinkedHashMap 继承了HashSet，唯一与之不同的是内部维护的是LinkedHashMap而不是HashMap：
/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.)... **/ HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor); } TreeSet内部也是维护了一个NavigableMap（TreeMap）。 详情请看Map。
List常用类数据结构 ArrayList内部维护了一个Object数组transient Object[] elementData;
LinkedList是链表结构，内部构造了含有前后指针的Node;
Stack extend Vector，所以内部也是一个Object数组，通过数组实现栈（先进后出），每次出栈最后一个数组元素。</description></item><item><title>Collection:ArrayList源码/扩容机制</title><link>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 17 Jun 2020 14:53:38 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid><description>ArrayList继承体系 implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable 你会发现既然ArrayList继承了AbstractList（它implement List接口），为啥后面还加了个implement List&amp;lt;E&amp;gt;，网上给出的解释是：
implement List&amp;lt;E&amp;gt; 是可以省略的，只是为了直观显示ArrayList实现了List接口，因为AbstractList只是为了减少实现List接口的代码。
RandomAccess、Cloneable、Serializable，可随机读写、可克隆、可序列化。
Field private static final int DEFAULT_CAPACITY = 10默认容量10
private static final Object[] EMPTY_ELEMENTDATA = {} 共享的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} 共享的空数组
transient Object[] elementData ArrayList元素存放的数据结构-数组
你会注意到EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA只是两个名字不通的空数组，为啥会需要两个呢？
观察构造器public ArrayList(int initialCapacity)指定容量为0的话，ArrayList会使用EMPTY_ELEMENTDATA，
而无参构造器则会使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA
这两个有什么不通呢？答案是容量增长方式不一样
private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } 可以看到第二个默认容量是10，而第一个是0，表现为：</description></item><item><title>Collection 体系和常用类</title><link>https://haomega.github.io/myblog/posts/collection-%E4%BD%93%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8%E7%B1%BB/</link><pubDate>Tue, 12 May 2020 17:55:28 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-%E4%BD%93%E7%B3%BB%E5%92%8C%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid><description>Collection体系 Collection：是一组数据的集合
Set 集 （不包含重复、无序） List 列表 （包含重复、有序) Quene 队列 （先进后出） Collection接口 定义了基本的集合方法
add/addAll 添加一个到集合中 remove/removeAll/removeIf 从集合中移除元素 contains/containsAll 判断集合是否包含 size 集合大小 clear 清空集合 retainAll 交集 Set 完全是Collection的实现，没有新增什么方法。
List 增加了基于Index操作的相关方法：
get(i)/set(i)/remove 根据下标获取/设置/删除 indexOf/lastIndexOf Quene 增加了队列的相关操作：
poll/remove 删除头部的一个元素 peek 偷看 常用类 从Collection体系图中可以看出：
Set：HashSet List：ArrayList Quene： HashSet 内部维护了一个HashMap，基本上都是在间接操作里面的HashMap
ArrayList 日常用到的最多，如果没有特殊的需求，一般都会用它。 特点是内部维护了数组，查找快、增删慢（如果删除中间的元素，后面的元素还要依次进一） 内部数据结构： Object数组
Map体系 键值对映射，不属于Collection Map接口 定义了键值对操作的方法，内部还包含了Entry接口
put/putAll 新增键值对 remove 删除 get 根据key获取value containsKey/containsValue 判断包含 clear 清空 keySet/values/entrySet 返回Map的key视图/value视图/entry视图 replace 替换 注意: Map视图是map内的真实映射，对视图操作就是对map操作</description></item></channel></rss>