<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>collection on 小豪小豪</title><link>https://haomega.github.io/myblog/tags/collection/</link><description>Recent content in collection on 小豪小豪</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Wed, 17 Jun 2020 14:53:38 +0800</lastBuildDate><atom:link href="https://haomega.github.io/myblog/tags/collection/index.xml" rel="self" type="application/rss+xml"/><item><title>Collection:ArrayList源码/扩容机制</title><link>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 17 Jun 2020 14:53:38 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid><description>ArrayList继承体系 implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable 你会发现既然ArrayList继承了AbstractList（它implement List接口），为啥后面还加了个implement List&amp;lt;E&amp;gt;，网上给出的解释是：
implement List&amp;lt;E&amp;gt; 是可以省略的，只是为了直观显示ArrayList实现了List接口，因为AbstractList只是为了减少实现List接口的代码。
RandomAccess、Cloneable、Serializable，可随机读写、可克隆、可序列化。
Field private static final int DEFAULT_CAPACITY = 10默认容量10
private static final Object[] EMPTY_ELEMENTDATA = {} 共享的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} 共享的空数组
transient Object[] elementData ArrayList元素存放的数据结构-数组
你会注意到EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA只是两个名字不通的空数组，为啥会需要两个呢？
观察构造器public ArrayList(int initialCapacity)指定容量为0的话，ArrayList会使用EMPTY_ELEMENTDATA，
而无参构造器则会使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA
这两个有什么不通呢？答案是容量增长方式不一样
private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } 可以看到第二个默认容量是10，而第一个是0，表现为：</description></item></channel></rss>