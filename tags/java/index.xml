<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on 小豪小豪</title><link>https://haomega.github.io/myblog/tags/java/</link><description>Recent content in java on 小豪小豪</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Wed, 17 Jun 2020 14:53:38 +0800</lastBuildDate><atom:link href="https://haomega.github.io/myblog/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Collection:ArrayList源码/扩容机制</title><link>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 17 Jun 2020 14:53:38 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-arraylist-%E6%BA%90%E7%A0%81-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid><description>ArrayList继承体系 implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable 你会发现既然ArrayList继承了AbstractList（它implement List接口），为啥后面还加了个implement List&amp;lt;E&amp;gt;，网上给出的解释是：
implement List&amp;lt;E&amp;gt; 是可以省略的，只是为了直观显示ArrayList实现了List接口，因为AbstractList只是为了减少实现List接口的代码。
RandomAccess、Cloneable、Serializable，可随机读写、可克隆、可序列化。
Field private static final int DEFAULT_CAPACITY = 10默认容量10
private static final Object[] EMPTY_ELEMENTDATA = {} 共享的空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {} 共享的空数组
transient Object[] elementData ArrayList元素存放的数据结构-数组
你会注意到EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA只是两个名字不通的空数组，为啥会需要两个呢？
观察构造器public ArrayList(int initialCapacity)指定容量为0的话，ArrayList会使用EMPTY_ELEMENTDATA，
而无参构造器则会使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA
这两个有什么不通呢？答案是容量增长方式不一样
private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } 可以看到第二个默认容量是10，而第一个是0，表现为：</description></item><item><title>Exception 体系概要</title><link>https://haomega.github.io/myblog/posts/exception-%E6%A6%82%E8%BF%B0/</link><pubDate>Thu, 28 May 2020 13:55:18 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/exception-%E6%A6%82%E8%BF%B0/</guid><description>概要 程序并不是每次都能按照理想情况运行，总是有着不可预测的异常情况发生。
作用 正确处理异常可以使程序更健壮； 异常给方法提供了除了return之外的额外的返回途径； Java中的异常结构 Java中的异常大致分为两类：Exception和Error，他们都继承自Throwable，意思是可抛出的异常;
Exception:(checked) 往往可以通过正确处理来避免；例如NullPointorException * runtimeException：运行时异常（unchecked） Error：（unchecked） 程序无能为力的异常；例如NoSuchClassError、OutOfmemoryError
异常的处理 有两种方式来处理异常
抛出 捕获 当你的的程序在某些情况不能正确执行：你可以抛出一个异常来警告调用者，或者捕获异常并处理。 当你的程序调用一个抛出异常的接口时： * 继续抛出这个异常 * 捕获并处理它（切记不可捕获了异常时不做任何处理） * 捕获它，doSomething并继续抛出此异常或另一个异常
异常处理原则 能用if/else或者其他能处理的，不要用异常 尽早抛出异常 带出重要信息 一旦捕获异常除非特别的，必须进行处理或者重新抛出。 ···· 其他 不捕获，一直抛出会发生什么？ 异常会击穿方法，直到被捕获，如果一直到最外层都没有捕获，则会杀掉当前线程。
catch/finally里的return finally一定会被执行，所以最终return的是finally块里的，另：不要再catch里return，这是不好的做法。
日志里的caused by是什么？ 出现caused by是异常被捕获后，重新由新的异常包裹（throw new XXXException(&amp;ldquo;some things&amp;rdquo;, e)）并抛出。</description></item></channel></rss>