<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>map on 小豪小豪</title><link>https://haomega.github.io/myblog/tags/map/</link><description>Recent content in map on 小豪小豪</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Sat, 11 Jul 2020 16:00:33 +0800</lastBuildDate><atom:link href="https://haomega.github.io/myblog/tags/map/index.xml" rel="self" type="application/rss+xml"/><item><title>HashMap 容量为什么是2的幂</title><link>https://haomega.github.io/myblog/posts/collection-hashmap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82/</link><pubDate>Sat, 11 Jul 2020 16:00:33 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/collection-hashmap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82/</guid><description>HashMap桶的容量 HashMap是散列表的实现，使用桶+链表的数据结构；
将元素散列在各个桶中，HashMap默认的负载因子是0.75f，这是一个对于空间和时间取舍上的一个值，当元素和桶的数量超过负载因子时，桶会进行扩容，但是桶的容量一直保持为2的幂：
在初始化HashMap时，桶的容量为2的幂； 当HashMap桶的容量不够进行扩容时，桶的容量也是2的幂; Why？ 当我们put一个值到HashMap时，会有如下步骤：
计算key的hashcode； 依据key的hashcode决定存储位置，会对hashcode取余； 将key-value放入桶。 在进行第2步时，HashMap不是使用%进行取余，而是index = (n - 1) &amp;amp; hash
可以这样理解：
当n为2的幂时，比如n=8，二进制表示为1000，所以（n-1）的二进制为0111，进行&amp;amp;操作时，能快速的丢弃除后三位的所有1 这样就不用取余计算了，我们知道取余计算是乘法运算，与位运算相比，位运算更加快速。</description></item></channel></rss>