<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>maven on 小豪小豪</title><link>https://haomega.github.io/myblog/tags/maven/</link><description>Recent content in maven on 小豪小豪</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><lastBuildDate>Mon, 11 May 2020 17:30:59 +0800</lastBuildDate><atom:link href="https://haomega.github.io/myblog/tags/maven/index.xml" rel="self" type="application/rss+xml"/><item><title>Java的包管理与Maven</title><link>https://haomega.github.io/myblog/posts/%E5%8C%85%E7%AE%A1%E7%90%86-maven/</link><pubDate>Mon, 11 May 2020 17:30:59 +0800</pubDate><guid>https://haomega.github.io/myblog/posts/%E5%8C%85%E7%AE%A1%E7%90%86-maven/</guid><description>Java程序如何执行？ 在Jvm中，它只做很简单的一件事，找到这个类并执行它，如果类中引用了其他的类，则继续找到引用的这个类，继续执行。
Jvm如何找到类？ 在Jvm中，所有的类使用全限定类名，Jvm也是根据全限定类名找到这个类； 查询机制：与熟悉的Path环境变量相同，Jvm从classpath按照Path的顺序依次查找。
当我们引入第三方包时，需要怎么做？ 首先你需要有源文件（jar文件)，然后告诉Jvm去哪里可以找到它，也就是指定classpath。
Maven做了什么？ 在管理依赖的方面，Maven就是从它的仓库中通过你定义的坐标
&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; 找到并下载该jar。
包冲突 根据Jvm执行的机制可以知道，包冲突就是在classpath中存在全限定类名相同的类，我们想要使用的jar包的path排在了不想要的后面，导致了错误的引用。 解决方法也是围绕着能够让Jvm能够正确读取我们想要的类为前提来进行。</description></item></channel></rss>